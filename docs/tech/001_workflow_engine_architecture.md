# Architecture: The Declarative Workflow Engine

This document outlines the architecture of our core execution system, designed to empower an AI to autonomously plan and execute complex tasks.

## 1. Core Philosophy: From Code to Data

Our primary architectural shift is moving the "how" of execution from rigid, procedural code into a flexible, declarative data format.

- **Old Way (Imperative):** An orchestrator class directly instantiates and calls methods on specific agent classes. The workflow is defined in TypeScript code.
- **New Way (Declarative):** An AI Planner generates a **Plan** (a JSON object) that describes the workflow. A generic **Executor** then interprets this Plan and executes the necessary **Tools**.

This approach is fundamentally more AI-native. The AI's core competency is generating structured data, not writing complex, coupled code.

## 2. The Three Pillars

Our engine stands on three pillars: **Tools**, **Plans**, and the **Executor**.

### a. Pillar 1: Tools (The "Verbs")

A **Tool** is the smallest, most fundamental unit of capability in our system. It's a "verb"â€”a specific action the AI can choose to perform.

- **Characteristics:**
  - **Stateless:** Receives all necessary data via inputs, produces a defined output, and holds no memory of past executions.
  - **Self-Describing:** Each tool has a manifest (`name`, `description`, `inputSchema`, `outputSchema`) that allows the AI to understand what it does, what it needs, and what it produces.
  - **Atomic:** A tool should perform a single, well-defined task (e.g., `read_file`, `run_shell_command`, `create_project_architecture`).

- **Registry:** All available tools are registered in a central `ToolRegistry`, which the AI can query to discover its available capabilities.

### b. Pillar 2: Plans (The "Blueprint")

A **Plan** is the blueprint for a task, generated by the AI Planner. It's a JSON object that defines a Directed Acyclic Graph (DAG) of steps.

- **Structure:**
  - `name`: A descriptive name for the plan.
  - `steps`: An array of `PlanStep` objects.
    - `id`: A unique identifier for the step (e.g., `design_phase`).
    - `tool`: The name of the tool to execute.
    - `inputs`: An object providing the inputs for the tool. These can be static values or dynamic references to the outputs of previous steps (e.g., `{"architecture": "${steps.design_phase.outputs.project}"}`).
    - `dependencies`: An array of step IDs that must complete before this step can run.

### c. Pillar 3: The Workflow Executor (The "Engine")

The **Executor** is the engine that brings a Plan to life. It is a generic, stateless service.

- **Responsibilities:**
  1.  **Parse the Plan:** Understand the steps and their dependencies.
  2.  **Resolve Dependencies:** Execute steps in the correct order, respecting the DAG. It can run independent steps in parallel.
  3.  **Resolve Inputs:** Use the outputs of completed steps to populate the inputs for subsequent steps by resolving placeholders (e.g., `${...}`).
  4.  **Execute Tools:** Look up the required tool in the `ToolRegistry` and execute it with the resolved inputs.
  5.  **Aggregate Outputs:** Collect the results of each step and provide a final summary.

## 3. The Grand Vision: A Self-Extending System

This architecture is not static. It's designed to grow. The ultimate goal is for the AI itself to be able to create new Tools on the fly, enabling it to solve problems it wasn't explicitly programmed to handle. This creates a virtuous cycle of learning and capability expansion, paving the way for true autonomous operation.
