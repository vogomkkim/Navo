짧게 결론부터.

## 결론

* **지금은 BFF(프론트 전용 게이트웨이) 레이어를 두는 게 맞다.**
  초기엔 **Express/Fastify(추천)** + TypeScript로 두고, **최종적으로 Go가 안정화되면 BFF도 Go(Gin/Chi/Fiber)로 옮겨** “더블 홉”을 없애라.
* 단, **BFF가 아무 가치(조인/캐시/권한/실험/안티-커럽션)도 안 하면 굳이 두지 마라.** 그땐 React → Go 단일 홉.

## 왜 BFF를 두나?

프론트엔드가 원하는 응답 형태/속도/권한을 맞추려면 프론트 전용 조합 계층이 필요함.

* **응답 조합**: 여러 Go 서비스에서 데이터 모아 한 번에 내려줌.
* **프론트 전용 정책**: 권한/AB 테스트/feature flag/실험 토글/서버 캐시.
* **안티-커럽션**: Go 도메인 모델 바뀌어도 프론트 API 계약 안정화.
* **이행 전략**: 지금 Express로 시작 → 점진적으로 Go로 교체(스트랭글러 패턴).

## 언제 굳이 안 두나?

* 클라이언트가 1종(SPA 하나), API가 단순 CRUD, 실시간/저지연 최우선 → **직결**이 더 낫다.
* 프론트 조합/캐시/실험이 전혀 필요 없고, API 계약이 장기간 안정적일 때.

## 추천 아키텍처(현실적인 단계별)

**1) 현재 (빠른 실행) — Node BFF**

* **Fastify + TS** (Express보다 빠르고 타입 친화적)
* **구성**

  * 인증: JWT(또는 Supabase 세션) 검증 미들웨어
  * 스키마 검증: Zod/TypeBox(+AJV)
  * 보안: helmet, rate-limit, CORS 최소화
  * 로깅/추적: pino + request-id + OpenTelemetry 헤더 전파
  * 캐시: Redis(핫 엔드포인트 TTL)
  * 라우팅: `/api/*`는 BFF, 내부로는 Go 서비스 프록시/조합
* **계약 관리**: OpenAPI 생성(자동 문서+스키마 공유)

**2) 전환기 — 스트랭글러 패턴**

* 경로/도메인 단위로 Go 서비스가 준비될 때마다 **BFF에서 역프록시 → Go**, 기존 Node 핸들러 제거.
* 계약(OpenAPI) 고정, 구현체만 바꾸기.

**3) 최종 — Go 중심**

* 트래픽 큰 엔드포인트부터 **Go로 BFF 자체를 대체**(Gin/Chi/Fiber).
* 필요하면 **API Gateway(Cloudflare/Nginx/Traefik/Envoy)** 앞단에 두고, TLS/Rate-limit/WAF는 게이트웨이에 일임.

## 의사결정 체크리스트

* 프론트 맞춤 **응답 조합/캐시/권한/실험** 필요? → **BFF 두자**
* 지연에 극도로 민감하고 API 단순? → **직결**
* 팀 역량: 지금은 JS/TS가 빠름, 최종은 Go 예정 → **Node로 시작, Go로 치환**

## 구현 팁(보안/운영)

* **권한 스냅샷**: BFF에서 토큰→역할/권한을 정규화하고 하위 서비스로 최소 권한 컨텍스트만 전달.
* **에러 매핑**: 내부(Go) 에러 코드를 BFF에서 일관된 에러 스펙으로 변환(프론트 안정).
* **관측성**: traceparent 헤더 전파, 모든 hop에 동일 trace id.
* **계약 테스트**: OpenAPI 기반 컨슈머 테스트로 프론트-BFF 계약 고정.

---

한 줄로: **지금은 Fastify BFF로 속도·안정 챙기고, 기능/트래픽 커지면 동일 계약 유지한 채 BFF와 코어를 Go로 점진 치환.**
