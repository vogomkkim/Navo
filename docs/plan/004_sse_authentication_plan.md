# 계획: SSE 인증 구현

**버전:** 1.0
**상태:** 제안됨

---

## 1. 목표

서버에서 전송하는 이벤트(SSE) 엔드포인트(`/api/sse/projects/:projectId`)에 티켓 기반 인증 메커니즘을 구현하여 보안을 강화합니다. 이를 통해 인가되지 않은 사용자가 프로젝트의 실시간 이벤트 스트림을 구독하는 것을 방지합니다.

## 2. 핵심 원칙

**"연결을 위한 인증, 지속을 위한 연결."**

인증 절차는 SSE 연결을 시작하는 최초의 순간에만 필요합니다. 일단 연결이 성공적으로 인증되면, 그 연결은 더 이상의 인증 확인 없이, 연결이 유지되는 동안 계속 유효한 것으로 간주합니다.

## 3. 아키텍처: 티켓 기반 인증

브라우저의 표준 `EventSource` API는 `Authorization`과 같은 커스텀 헤더 전송을 지원하지 않으므로, 짧은 유효 시간을 가진 일회용 "티켓"을 쿼리 파라미터로 전달하는 방식을 사용합니다.

### 워크플로우:

1.  **클라이언트가 티켓 요청:** 프론트엔드는 SSE 연결을 시작하기 직전, 인증이 필요한 새로운 엔드포인트(`POST /api/sse/ticket`)에 `POST` 요청을 보냅니다.
2.  **서버가 티켓 발급:** 서버는 사용자의 세션을 확인하고, 짧은 만료 시간(예: 15초)을 가진 일회용 티켓을 생성합니다. 이 티켓은 사용자의 ID와 매핑되어 Redis나 인-메모리 캐시와 같은 임시 저장소에 저장된 후, 클라이언트에게 반환됩니다.
3.  **클라이언트가 티켓으로 연결:** 클라이언트는 발급받은 티켓을 쿼리 파라미터에 포함하여 `EventSource` 객체를 생성하고 SSE 연결을 시작합니다.
    - `new EventSource('/api/sse/projects/PROJECT_ID?ticket=TICKET_STRING')`
4.  **서버가 티켓 검증:** SSE 엔드포인트 핸들러는 요청의 쿼리 파라미터에서 티켓을 추출하여 캐시에 저장된 티켓과 비교하여 유효성을 검증합니다.
    - **유효한 경우:** 서버는 재사용을 방지하기 위해 캐시에서 해당 티켓을 **즉시 삭제**하고, 티켓에 연결된 사용자 ID를 확인하여 인증을 완료한 후 SSE 연결을 수립합니다.
    - **유효하지 않은 경우 (없거나 만료됨):** 서버는 `401 Unauthorized` 또는 `403 Forbidden` 에러를 반환하고 연결을 거부합니다.

---

## 4. 세부 실행 계획

### 1단계: 서버 측 구현

1.  **티켓 저장소 생성:**
    - SSE 티켓을 저장하기 위한 간단한 인-메모리 시간 기반 캐시를 구현합니다. `Map` 객체를 사용하여 티켓을 키로, `{ userId, expiresAt }` 객체를 값으로 저장하는 방식이면 충분합니다.
    - 이 로직은 `workflow.controller.ts` 내부나, 단순화를 위해 새로운 전용 서비스에 구현합니다.

2.  **티켓 발급 엔드포인트 생성:**
    - `workflow.controller.ts`에 새로운 라우트 `POST /api/sse/ticket`을 생성합니다.
    - 이 라우트는 반드시 `app.authenticateToken` 미들웨어를 통과해야 합니다.
    - 핸들러의 역할:
        - 암호학적으로 안전한 무작위 문자열을 티켓으로 생성합니다.
        - 티켓, `userId`, 만료 시간(예: `Date.now() + 15000`)을 티켓 저장소에 저장합니다.
        - `{ "ticket": "..." }` 형태의 JSON 응답으로 티켓을 클라이언트에게 반환합니다.

3.  **SSE 엔드포인트 인증 로직 추가:**
    - `workflow.controller.ts`의 `GET /api/sse/projects/:projectId` 핸들러를 수정합니다.
    - 핸들러 시작 부분에서 `request.query`로부터 `ticket`을 추출합니다.
    - 티켓이 없으면 즉시 `401` 에러로 요청을 거부합니다.
    - 티켓 저장소에서 티켓을 조회합니다.
    - 티켓이 존재하고 만료되지 않았다면:
        - **즉시 티켓을 저장소에서 삭제합니다.**
        - 티켓에 연결된 `userId`를 가져옵니다.
        - (선택사항이지만 권장) 이 `userId`가 요청된 `projectId`에 접근할 권한이 있는지 추가로 확인합니다.
        - SSE 연결 수립 절차를 계속 진행합니다.
    - 티켓이 없거나 만료되었다면, `401` 에러로 요청을 거부합니다.

### 2단계: 클라이언트 측 구현

1.  **티켓 요청 API 클라이언트 함수 생성:**
    - `frontend/src/lib/apiClient.ts`에 `fetchSseTicket(token: string): Promise<{ ticket: string }>` 함수를 새로 만듭니다.
    - 이 함수는 `/api/sse/ticket`에 `POST` 요청을 보냅니다.

2.  **`useWorkflowEvents` 훅 수정:**
    - `frontend/src/hooks/useWorkflowEvents.ts`의 `useEffect` 훅을 수정합니다.
    - `EventSource` 객체를 생성하기 직전에, `async` 함수로 만들고 내부에서 `fetchSseTicket`을 호출하여 티켓을 받아옵니다.
    - 받아온 티켓을 사용하여 쿼리 파라미터가 포함된 `EventSource` URL을 구성합니다.
    - 티켓을 받아오는 과정에서 발생할 수 있는 에러를 처리합니다.