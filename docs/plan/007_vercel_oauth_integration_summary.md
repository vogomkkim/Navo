# Vercel OAuth 2.0 연동 기능 구현 요약

**날짜:** 2025년 9월 23일
**상태:** 구현 완료 (서버 측)

## 진행 배경: Live Preview의 진정한 완성을 위하여

Navo의 핵심 기능인 Live Preview는 초기에 사용자의 UI 코드를 실시간으로 렌더링하는 데 중점을 두었습니다. 하지만 이는 '엔진 없는 쇼룸 자동차'와 같아, 실제 백엔드 기능(데이터 조회, 폼 제출 등)과 연동되지 않는 한계가 명확했습니다. 진정한 'Live' 환경을 제공하기 위해서는 사용자 프로젝트가 자신만의 백엔드를 가질 수 있어야 했습니다.

초기에는 Navo 플랫폼 자체의 API를 호출하여 이 문제를 해결하려 했으나, 이는 사용자의 근본적인 요구사항과 다르다는 것을 깨달았습니다. 사용자가 원하는 것은 **자신이 만든 프로젝트 내부의 API(예: 웹사이트의 로그인 기능)**가 Live Preview에서 동작하는 것이었습니다.

이를 해결하기 위해, 사용자 프로젝트에 백엔드 기능을 제공하는 방안을 모색했습니다. 자체 실행 환경을 구축하는 대신, 개발 속도와 안정성을 고려하여 우리가 이미 프론트엔드 배포에 사용하고 있는 **Vercel의 서버리스 함수(Serverless Functions)를 활용**하는 전략을 채택했습니다. 이 방식은 Next.js의 API Routes 기능을 통해 프론트엔드와 백엔드를 하나의 프로젝트 안에서 완벽하게 통합할 수 있는 가장 효율적인 접근법입니다.

이 전략을 실행하기 위한 **필수 선행 조건**이 바로 Vercel OAuth 2.0 연동입니다. Navo가 사용자를 대신하여 Vercel에 프로젝트를 배포하고, 배포된 API 주소를 Live Preview 프록시에서 사용하려면, 먼저 사용자로부터 안전하게 권한을 위임받아야 합니다. 따라서 이 문서는 그 첫 단추인 OAuth 연동 기능의 구현 과정을 상세히 기록합니다.

## 1. 핵심 목표

사용자가 단 한 번의 클릭으로 자신의 Vercel 계정을 Navo 플랫폼에 안전하게 연결하고, Navo가 사용자를 대신하여 Vercel 프로젝트를 생성 및 배포할 수 있는 권한을 부여하는 기반을 마련한다.

## 2. 핵심 아키텍처 결정사항

Access Token의 안전하고 지속적인 관리를 위해 다음과 같은 아키텍처를 채택했다.

### 가. 토큰 저장소: 데이터베이스
- 사용자별 `Access Token`과 `Refresh Token`은 **서버 측 데이터베이스**에 저장한다.
- 이를 위해 `vercel_integrations`라는 새로운 테이블을 스키마에 정의했다.
- **이유:** 프론트엔드(브라우저) 저장을 피하여 토큰 탈취 위험을 원천적으로 차단하고, 서버가 언제든지 토큰에 접근하여 API 호출 및 갱신을 수행할 수 있도록 한다.

**🔧 설계 관점 코멘트:**
- **장점:** 보안성과 중앙 집중식 관리가 가능한 설계
- **개선점:** 현재는 단일 연동만 고려됨. 향후 다중 연동(여러 Vercel 계정) 시나리오를 고려하면 `provider` 필드 추가 필요
- **확장성:** 토큰 메타데이터(`expiresAt`, `scope`, `status`) 추가로 더 정교한 생명주기 관리 가능

### 나. 보안: 대칭키 암호화
- 데이터베이스에 토큰을 저장하기 전, Node.js의 내장 `crypto` 모듈(AES-256-GCM)을 사용하여 **반드시 암호화**한다.
- 암/복호화에 사용될 비밀 키는 환경 변수(`VERCEL_ENCRYPTION_KEY`)를 통해 안전하게 관리한다.
- **이유:** 데이터베이스가 유출되더라도, 암호화 키 없이는 토큰을 해독할 수 없으므로 사용자의 Vercel 계정을 안전하게 보호할 수 있다.

**🔧 설계 관점 코멘트:**
- **장점:** AES-256-GCM은 인증된 암호화로 무결성과 기밀성 모두 보장
- **개선점:** 현재는 단순한 암호화 유틸리티 수준. 토큰 생명주기 관리까지 포함하는 `TokenManager` 인터페이스로 확장 고려
- **보안 고려:** 키 로테이션 전략과 백업 복구 절차가 설계에 포함되지 않음

### 다. 지속성: 리프레시 토큰 (Refresh Token)
- 유효기간이 짧은 `Access Token`이 만료되더라도 사용자가 다시 인증할 필요가 없도록, 유효기간이 긴 `Refresh Token`을 함께 저장한다.
- `Access Token` 만료 시, 서버가 백그라운드에서 자동으로 `Refresh Token`을 사용하여 새로운 토큰들을 재발급하고 데이터베이스를 업데이트한다.
- **이유:** 최초 한 번의 인증으로 지속적인 서비스 이용이 가능한 매끄러운 사용자 경험(UX)을 제공하기 위함이다.

**🔧 설계 관점 코멘트:**
- **장점:** 사용자 경험을 크게 개선하는 설계
- **개선점:** 토큰 갱신 실패 시 처리 전략이 명시되지 않음 (재인증 유도, 에러 핸들링)
- **복원력:** 갱신 실패 시 백오프 전략과 재시도 로직이 설계에 포함되지 않음

## 3. 상세 구현 내역

### 가. 데이터베이스 계층 (Drizzle ORM)

1.  **스키마 정의 (`server/drizzle/schema.ts`):**
    - `vercel_integrations` 테이블을 새롭게 정의했다.
    - 주요 컬럼:
        - `id`: 기본 키 (UUID)
        - `userId`: `users` 테이블을 참조하는 외래 키. 한 사용자는 하나의 연동 정보만 가질 수 있도록 `unique` 제약 조건 추가.
        - `accessToken`: 암호화된 Access Token 저장 (text)
        - `refreshToken`: 암호화된 Refresh Token 저장 (text)
        - `teamId`: Vercel 팀 ID (선택 사항)
        - `createdAt`, `updatedAt`: 타임스탬프

2.  **마이그레이션 파일 생성:**
    - `npm run db:generate` 스크립트를 실행하여 스키마 변경사항을 감지했다.
    - `server/drizzle/0004_chief_mach_iv.sql` 마이그레이션 파일이 성공적으로 생성되었다.

**🔧 설계 관점 코멘트:**
- **장점:** 명확한 외래 키 관계와 unique 제약으로 데이터 무결성 보장
- **개선점:** 토큰 생명주기 관리를 위한 `expiresAt`, `scope`, `status` 필드 부재
- **확장성:** 현재는 단일 연동만 고려. 다중 연동 시 `provider` 필드 추가 필요

### 나. 보안 계층 (암호화 유틸리티)

1.  **파일 생성 (`server/src/lib/crypto.ts`):**
    - `encrypt(text)`와 `decrypt(encryptedText)` 함수를 구현했다.
    - `aes-256-gcm` 알고리즘을 사용하며, IV(초기화 벡터)와 인증 태그를 포함하여 보안성을 높였다.
    - 환경 변수 `VERCEL_ENCRYPTION_KEY`를 64자리의 16진수 문자열(32바이트)로 사용하도록 설정했다.

**🔧 설계 관점 코멘트:**
- **장점:** AES-256-GCM은 인증된 암호화로 무결성과 기밀성 모두 보장하는 안전한 선택
- **개선점:** 현재는 단순한 유틸리티 함수 수준. 토큰 생명주기 관리까지 포함하는 `TokenManager` 클래스로 확장 고려
- **아키텍처:** 암호화 로직이 비즈니스 로직과 분리되어 있어 관심사 분리 원칙을 잘 따름

### 다. 애플리케이션 계층 (Vercel 모듈)

`Controller` -> `Service` -> `Repository`의 3-Tier 아키텍처 패턴에 따라 모듈을 설계했다.

1.  **Repository (`server/src/modules/vercel/vercel.repository.ts`):**
    - 데이터베이스와의 모든 상호작용을 담당한다.
    - `upsertIntegration` 메서드를 구현하여, 새로운 연동 정보는 생성하고 기존 정보는 업데이트하는 로직을 작성했다.

2.  **Service (`server/src/modules/vercel/vercel.service.ts`):**
    - 핵심 비즈니스 로직을 처리한다.
    - `exchangeCodeForToken` 메서드를 구현했다.
        - Vercel API (`/v2/oauth/access_token`)를 실제로 호출하여 `code`를 토큰으로 교환한다.
        - 응답으로 받은 `access_token`과 `refresh_token`을 `crypto.encrypt` 함수를 사용해 암호화한다.
        - 암호화된 토큰들을 `VercelRepository`를 통해 데이터베이스에 저장한다.

3.  **Controller (`server/src/modules/vercel/vercel.controller.ts`):**
    - HTTP 요청과 응답을 처리한다.
    - `Fastify` 프레임워크 스타일에 맞게, `app` 인스턴스를 인자로 받는 함수형 컨트롤러로 작성했다.
    - **`GET /auth`:**
        - `app.authenticateToken` 미들웨어를 통해 로그인한 사용자만 접근 가능하다.
        - CSRF 공격 방지를 위해 `state` 파라미터에 `userId`를 담아 Vercel 권한 동의 페이지로 리디렉션한다.
    - **`GET /callback`:**
        - Vercel로부터 `code`와 `state`를 받는다.
        - `state` 값(userId)을 통해 어떤 사용자의 요청인지 식별한다.
        - `VercelService`를 호출하여 토큰 교환 및 저장 로직을 실행한다.

**🔧 설계 관점 코멘트:**
- **장점:** 명확한 3-Tier 아키텍처로 관심사 분리가 잘 되어 있음
- **개선점:** 에러 처리 전략이 명시되지 않음 (토큰 교환 실패, 네트워크 오류 등)
- **확장성:** 현재는 단일 연동만 고려. 다중 연동 시 인터페이스 기반 설계로 확장 필요
- **복원력:** 토큰 갱신 실패 시 재시도 로직과 백오프 전략이 부재

### 라. 서버 통합 및 설정

1.  **설정 파일 수정 (`server/src/config/index.ts`):**
    - `config` 객체에 `vercel` 속성을 추가했다.
    - `clientId`, `clientSecret`, `redirectUri`, `encryptionKey`를 환경 변수로부터 읽어오도록 설정했다.

2.  **서버 진입점 수정 (`server/src/server.ts`):**
    - `vercelController`를 import 했다.
    - `app.register`를 사용하여 컨트롤러에 정의된 라우트들을 `/api/vercel` 경로 접두사와 함께 서버에 등록했다.

**🔧 설계 관점 코멘트:**
- **장점:** 설정과 라우팅이 명확하게 분리되어 있어 유지보수성이 좋음
- **개선점:** 환경별 설정 차이(dev/staging/prod)에 대한 고려가 부재
- **아키텍처:** 모듈화가 잘 되어 있어 다른 OAuth 제공자 추가 시 재사용 가능한 구조

## 4. 인증 흐름 (요약)

1.  **시작:** 로그인한 사용자가 프론트엔드의 [Vercel 연동] 버튼 클릭.
2.  **요청:** 브라우저가 `GET /api/vercel/auth` 요청.
3.  **리디렉션:** 서버가 `userId`를 `state`에 담아 Vercel 인증 페이지로 리디렉션.
4.  **권한 부여:** 사용자가 Vercel 사이트에서 권한 부여.
5.  **콜백:** Vercel이 브라우저를 `GET /api/vercel/callback?code=...&state=...`로 리디렉션.
6.  **토큰 교환:** 서버가 `code`와 `state`를 받아 Vercel API에 토큰 요청.
7.  **저장:** 서버가 받은 토큰을 암호화하여 DB에 저장.
8.  **완료:** 서버가 프론트엔드로 성공 응답 또는 리디렉션.

**🔧 설계 관점 코멘트:**
- **장점:** 표준 OAuth 2.0 플로우를 정확히 따르고 있어 보안성과 호환성이 좋음
- **개선점:** 각 단계별 에러 처리 시나리오가 명시되지 않음 (사용자 거부, 네트워크 오류 등)
- **보안:** CSRF 방지를 위한 `state` 파라미터 사용이 잘 설계됨
- **복원력:** 토큰 교환 실패 시 사용자에게 친화적인 에러 메시지 제공 전략 부재

## 5. 다음 단계 (필수 작업)

1.  **Vercel OAuth App 생성:** Vercel 대시보드에서 Integration을 생성하고 `Client ID`와 `Client Secret`을 발급받는다.
2.  **암호화 키 생성:** `openssl rand -hex 32` 등의 명령어로 64자리의 16진수 암호화 키를 생성한다.
3.  **.env 파일 업데이트:** `VERCEL_CLIENT_ID`, `VERCEL_CLIENT_SECRET`, `VERCEL_ENCRYPTION_KEY` 환경 변수를 .env 파일에 추가한다.
4.  **프론트엔드 구현:** 설정 페이지에 `/api/vercel/auth`로 연결되는 버튼을 추가한다.
5.  **DB 마이그레이션 실행:** 서버 시작 전, `drizzle-kit`으로 생성된 마이그레이션을 실제 데이터베이스에 적용해야 한다.

**🔧 설계 관점 코멘트:**
- **장점:** 구현 완료 후 필요한 작업들이 명확하게 정리되어 있음
- **개선점:** 에러 처리 및 모니터링 관련 작업이 누락됨 (토큰 갱신 실패 감지, 사용자 알림 등)
- **확장성:** 향후 다중 연동 지원을 위한 아키텍처 개선 작업이 고려되지 않음
- **운영:** 프로덕션 배포를 위한 보안 검토 및 성능 테스트 항목 부재
