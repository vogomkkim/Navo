/**
 * @file Implements the WorkflowExecutor, the engine that runs declarative Plans.
 */

import { Plan, PlanStep, ExecutionContext } from './types';
import { toolRegistry } from './toolRegistry';
import { randomUUID } from 'node:crypto';

/**
 * Executes a Plan by resolving dependencies and running the specified Tools.
 * This is the core of our autonomous AI's execution capability.
 */
export class WorkflowExecutor {
  /**
   * Executes a given plan.
   * @param plan The Plan object generated by the AI.
   * @param initialInputs Any initial data to be made available to the workflow.
   * @returns A map of step IDs to their outputs.
   */
  async execute(plan: Plan, initialInputs: Record<string, any> = {}): Promise<Map<string, any>> {
    if (!plan || !Array.isArray(plan.steps)) {
      throw new Error('Invalid plan: "steps" array is missing or not an array.');
    }

    const runId = randomUUID();
    console.log(`[WorkflowExecutor] Starting execution for plan "${plan.name}" (Run ID: ${runId})`);

    const executionContext: ExecutionContext = { runId };
    const stepOutputs = new Map<string, any>();
    const completedSteps = new Set<string>();

    // A simple way to handle DAG execution: loop until all steps are complete.
    // A more sophisticated implementation would use a topological sort.
    while (completedSteps.size < plan.steps.length) {
      const stepsReadyToRun = plan.steps.filter(step =>
        !completedSteps.has(step.id) &&
        (step.dependencies ?? []).every(dep => completedSteps.has(dep))
      );

      if (stepsReadyToRun.length === 0 && completedSteps.size < plan.steps.length) {
        const remainingSteps = plan.steps
          .filter(s => !completedSteps.has(s.id))
          .map(s => s.id);
        throw new Error(`Workflow stalled. Circular dependency or missing dependency detected. Remaining steps: ${remainingSteps.join(', ')}`);
      }

      const promises = stepsReadyToRun.map(step =>
        this.executeStep(step, executionContext, stepOutputs, initialInputs)
          .then(output => {
            stepOutputs.set(step.id, output);
            completedSteps.add(step.id);
          })
      );

      await Promise.all(promises);
    }

    console.log(`[WorkflowExecutor] Plan "${plan.name}" executed successfully.`);
    return stepOutputs;
  }

  private async executeStep(
    step: PlanStep,
    context: ExecutionContext,
    allOutputs: Map<string, any>,
    initialInputs: Record<string, any>
  ): Promise<any> {
    console.log(`[WorkflowExecutor] Executing step: ${step.id}`);

    const tool = toolRegistry.get(step.tool);
    if (!tool) {
      throw new Error(`Tool "${step.tool}" not found for step "${step.id}".`);
    }

    // Resolve inputs, replacing placeholders like "${steps.someStep.outputs.result}"
    const resolvedInputs = this.resolveInputs(step.inputs, allOutputs, initialInputs);

    try {
      // TODO: Add input validation against tool.inputSchema here.
      const output = await tool.execute(context, resolvedInputs);
      // TODO: Add output validation against tool.outputSchema here.

      console.log(`[WorkflowExecutor] Step ${step.id} completed successfully.`);
      return output;
    } catch (error) {
      console.error(`[WorkflowExecutor] Error executing step ${step.id}:`, error);
      // In a real implementation, add more robust error handling, retries, etc.
      throw error;
    }
  }

  /**
   * Resolves input values by replacing dynamic references with actual outputs from previous steps.
   * @param inputs The input object for a step.
   * @param outputs The map of all completed step outputs.
   * @param initialInputs The initial data passed to the workflow.
   * @returns A new object with all references resolved.
   */
  private resolveInputs(
    inputs: Record<string, any>,
    outputs: Map<string, any>,
    initialInputs: Record<string, any>
  ): Record<string, any> {
    const resolved: Record<string, any> = {};
    for (const key in inputs) {
      let value = inputs[key];

      if (typeof value === 'string') {
        const placeholderRegex = /\${(.*?)}/g;
        // Handle cases where the entire string is a placeholder for an object
        if (/^\${(.*?)}$/.test(value)) {
          const match = value.match(/^\${(.*?)}$/);
          if (match) {
            const placeholder = match[1].trim();
            const parts = placeholder.split('.');
            if (parts[0] === 'steps' && parts.length > 2 && parts[2] === 'outputs') {
              const stepId = parts[1];
              let stepOutput = outputs.get(stepId);
              if (stepOutput !== undefined) {
                let nestedValue = stepOutput;
                for (let i = 3; i < parts.length; i++) {
                  nestedValue = nestedValue?.[parts[i]];
                }
                resolved[key] = nestedValue;
                continue; // Skip to next key
              }
            }
          }
        }

        // Handle inline string replacements
        value = value.replace(placeholderRegex, (match, placeholder) => {
          const parts = placeholder.trim().split('.');
          if (parts[0] === 'steps' && parts.length > 2 && parts[2] === 'outputs') {
            const stepId = parts[1];
            let stepOutput = outputs.get(stepId);
            if (stepOutput !== undefined) {
              let nestedValue = stepOutput;
              for (let i = 3; i < parts.length; i++) {
                nestedValue = nestedValue?.[parts[i]];
              }
              return String(nestedValue); // Ensure it's a string for inline replacement
            }
          }
          return match; // Return original placeholder if not found
        });
      }
      resolved[key] = value;
    }
    return resolved;
  }
}
